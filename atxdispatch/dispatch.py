"""
Dispatch main module

Usage:
  dispatch [options]

Options:
  --no-web                       Do not run web interface
  --input-path <path>            Specifies path of data files (input)
  --output-path <path>           Specifies path of data files (output)
  --material-ini <fn>            Path to material.ini
  --captions-json <fn>           Path to captions.json
  --db <fn>                      Path to database file
  --import-minidisp              Import data from minidisp (autodetect path)
  --import-minidisp-path=<path>  Import data from minidisp (specify path)
  --import-atxd300               Import data from atxd300 (autodetect path)
  --import-atxd300-path=<path>   Import data from atxd300 (specify path)
  --clear                        Clears entire DB (after confirmation)
  --populate                     Populates database with test dummy data
  --bigdata <count>              Populates database with <count> of dummy data
                                 in orders, materials, recipes, cars, sites, customers and contracts
                                 (use it to stress test app on big amounts of data)
  --users                        Manage users
  --integrity-check              Run database integrity check
  --from-kdx <path>              Path to where KDX writes files to
  --to-kdx <path>                Path to where KDX reads files from
  --kdx-material-ini <path>      Path to material.ini file being generated by KDX

Note: to switch on/off modules, use HJSON configuration file. See manual.txt for details
"""
import json
import sys
import os
import hjson
import threading
import time
import logging
import docopt
import datetime
import arrow
import shutil
from peewee import DoesNotExist

import sqlite3  # just to log the version later on

from atxpylib.quitfile import QuitFile
from atxpylib.configparser import AtxConfigParser
import atxpylib.utils as atxutils
import atxpylib.comm as atxcomm

from .version import __version__
from . import glo
from . import web
from . import settings
from . import model
from . import model_utils
from . import importer
from . import func
from . import bridges
from .exceptions import UserInputError


_run = 1  # TODO NTH REF globals are ugly


def load_setup(setup_fn):
    ret = {}
    if os.path.isfile(setup_fn):
        logging.debug(f"loading config from {setup_fn}")
        # TODO NTH REF This config.cfg["setup"] slowly grows out of control. Should be refactored to (singleton) class
        ret = hjson.load(open(setup_fn, "r", encoding="utf-8"))

    # Check if this quacks as a dict - and if not, make it so
    try:
        _ = ret.keys()
    except AttributeError:
        ret = {}

    if "rounding_precision" not in ret:  # provide default value
        ret["rounding_precision"] = 2

    return ret


def load_captions(captions_fn):
    if os.path.isfile(captions_fn):
        logging.debug(f"loading captions from {captions_fn}")
        return json.load(open(captions_fn, "r", encoding="utf-8"))
    return {}


def material_types_get():
    d = {x: [] for x in model.Material.ALLOWED_TYPES}
    for material in model.Material.select():
        material_type = material.type
        if material_type in model.Material.ALLOWED_TYPES:
            d[material_type].append(material.as_json())
    return d


# TODO: is this function really needed? - maybe just inline it at caller
def linked_materials_get(recipe_id):
    try:
        recipe = model.Recipe.get_by_id(recipe_id)
    except DoesNotExist:
        return []
    return recipe._get_materials()


def cancel_order(order_id, data_path):
    """Cancels order: sends .ddd file and cancels order in DB"""
    record = model.Order.get_by_id(order_id)
    record.change_status(model.Order.STATUS_ABORTED)
    full_fn = func.asterixed_path(data_path, record.comm_filename("ddd"))
    atxcomm.order_to_ini_f({"Number": order_id}, full_fn)
    logging.info(f"Send 'cancel' command to manager via file: {full_fn}")


@model.db.atomic()
def new_pump_order(data):
    """ Create new pump order.
        data .. hashtable with data from POST request
             {
                "kms": ..., "hours": ...,
                "surcharges": [ {}, {}, ... ]
             }

    """
    # Auto numbering feature.
    # FIXME This code should be atomic, but it is not (state is saved outside DB,
    #   so decorator model.db.atomic does not handle it). Also copypasted with ```def produce()``` below. Options:
    #       a) refactor state to class, and provide something like state.get_incremented_counter(counter_name)
    #       b) create model.AutoNumbered mixin. Seems cleaner (counter name can be set in Meta class or so)
    state = func.state_load(settings.STATE_FILE)
    new_auto_number = int(state.get("pumporder_num_counter", 0)) + 1
    state["pumporder_num_counter"] = new_auto_number
    func.state_save(state, settings.STATE_FILE)

    record = model.PumpOrder(
        kms=data.get("kms", None),
        hours=data.get("hours", None),
        auto_number=new_auto_number,
    )
    record.set_pump(data["pump"])
    record.set_customer(data.get("customer", None))
    record.set_construction_site(data.get("construction_site", None))
    record.save()
    record.update_surcharges(data.pop("surcharges", []))

    return {"message": "{pump_order_created}"}


@model.db.atomic()
def produce(order, output_path, username):
    t = time.time()

    # Sanity check(s)
    try:
        sanitized_volume = float(order["volume"])
    except KeyError:
        raise UserInputError("{Volume must be specified}")
    except (TypeError, ValueError):
        raise UserInputError("{Volume must be number}")
    if not sanitized_volume:
        raise UserInputError("{Volume must be specified}")

    temperature = order.get("temperature", None)
    if temperature:
        temperature = float(temperature)
        try:
            assert temperature > settings.TEMPERATURE_USER_MIN
            assert temperature < settings.TEMPERATURE_USER_MAX
        except AssertionError:
            raise ValueError("{Temperature seems unrealistic}")

    recipe_id = order.pop("recipe_id", None)
    car_id = order.pop("car", None)  # Car identified by record id (MIDI version)
    vehicle_id = order.pop("vehicle_id", None)  # Car identified by registration number (MINI version)
    surcharges = order.pop("surcharges", [])

    if not any([car_id, vehicle_id]):
        raise UserInputError("{Vehicle must be specified}")

    try:
        recipe = model.Recipe.get_by_id(recipe_id)
    except DoesNotExist:
        raise UserInputError("{Recipe must be specified}")

    order_instance = model.Order()

    def copy_values(from_record, to_record, prefix, value_names):
        for value_name in value_names.strip().split(" "):
            # TODO REF: no introspection here!
            setattr(to_record, f"{prefix}{value_name}", getattr(from_record, value_name))

    # necessary for "take sample" feature
    production = recipe.get_or_create_production()
    production.volume_total += sanitized_volume
    production.save()

    order_instance.set_recipe(recipe_id)
    order_instance.write_audit_info(username)
    order_instance.temperature = temperature
    order_instance.set_transport_zone(order.pop("transport_zone", None))

    # Update program state - auto numbering feature, save temperature
    # FIXME This code should be atomic, but it is not (state is saved outside DB,
    #   so decorator model.db.atomic does not handle it)
    state = func.state_load(settings.STATE_FILE)
    state["order_num_counter"] = order_instance.auto_number = int(state.get("order_num_counter", 0)) + 1
    state["invoice_num_counter"] = order_instance.invoice_number = int(state.get("invoice_num_counter", 0)) + 1
    if temperature:
        state["temperature_by_user"] = temperature
    func.state_save(state, settings.STATE_FILE)

    try:
        customer_instance = model.Customer.get_by_id(order.pop("customer_id", None))
        order_instance.customer = customer_instance.name
        order_instance.customer_record = customer_instance
    except DoesNotExist:
        pass

    try:
        construction_site_instance = model.ConstructionSite.get_by_id(order.pop("site_id", None))
        order_instance.construction_site = construction_site_instance.name
        order_instance.construction_site_record = construction_site_instance
    except DoesNotExist:
        construction_site_instance = None

    # TODO: finish (something with contract id) for zapa . QUE RP: ok, but what functionality is required?
    #  JH: I already saved contract_id to the record. Is this all that was required? What to do with this then?
    try:
        contract = model.Contract.get_by_id(order.pop("contract_id", None))
        order_instance.contract_record = contract
        order_instance.contract_name = contract.name
    except DoesNotExist:
        pass

    order_instance.set_price(recipe)
    order_instance.update_from_json(order)
    order_instance.update_surcharges(surcharges)

    # Create instances of OrderMaterial from recipe.materials and link it to order
    for material in recipe.materials:
        model.OrderMaterial.create(
            type=material.material.type,
            name=material.material.name,
            long_name=material.material.long_name,
            unit=material.material.unit,
            comment=material.material.comment,
            material=material.material,
            sequence_number=material.sequence_number,
            order=order_instance,
            amount=material.amount,
            delay=material.delay,
            k_value=material.k_value,
            k_ratio=material.k_ratio,
        )

    # delivery is created here. theoretically it should be created after the car is full (after multiple batches - maybe after the order is complete) but some plants want this "in advance" as the concrete is being produced so that they can print it and hand it to the driver when he leaves the plant.
    delivery = model.Delivery.create(order=order_instance)
    if car_id:
        try:
            car = model.Car.get_by_id(car_id)
        except DoesNotExist:
            raise ValueError("{This vehicle does not exist}")
        delivery.car_record = car
        copy_values(car, delivery, "car_", "operator registration_number car_type price_per_km")
        if car.driver:
            delivery.car_driver = car.driver.name
            delivery.car_driver_contact = car.driver.contact
    elif vehicle_id:
        delivery.car_registration_number = vehicle_id

    delivery.set_construction_site(construction_site_instance)
    delivery.save()

    ord_fn = func.asterixed_path(output_path, order_instance.comm_filename("ord"))

    # Creating .ORD file - phase 1 - [Order] section
    order_to_file = {
        "t": t,
        "Time": arrow.get(t).to(settings.TIMEZONE).format("H:mm"),
        "Date": arrow.get(t).to(settings.TIMEZONE).format("DD.MM.YYYY"),
        "User": order.get("customer", ""),
        "Volume": sanitized_volume,
        "ID": order_instance.id,
        "Number": order_instance.auto_number,
        "Comment": order_instance.comment,
        "Without_Water": 1 if order_instance.without_water else 0,
        "Temperature": order_instance.temperature,
        "ConstructionSite": order.get("construction_site", ""),
        "VehicleIdentificationNumber": delivery.car_registration_number or "",
    }
    atxcomm.order_to_ini_f(order_to_file, ord_fn)

    materials = []
    material_iterator = {}
    for material in order_instance.materials:
        material_type = material.type
        material_iterator[material_type] = material_iterator.get(material_type, 0) + 1
        d = {
            "Name": material.name,
            "Long_Name": material.long_name,
            "Weight": material.amount,
            "Delay": material.delay,
            "ID": material.id,  # to pair material with production values received via .be2 file.
            "_k_orig": f"{material_type}{material_iterator[material_type]}",
        }

        if material_type == "Addition":
            d["K_value"] = material.k_value
            d["K_ratio"] = material.k_ratio

        materials.append(d)

    recipe_to_file = {
        "Number": recipe.number,
        "ID": recipe.id,  # primary key of DB record
        "Name": recipe.name,
        "Class": recipe.recipe_class,
        "Consistency_Class": recipe.consistency_class,
        "Comment": recipe.comment,
        "K_ratio": recipe.k_ratio,
        "ACCAWR": recipe.k_value,
        "Batch_Volume_Limit": recipe.batch_volume_limit,
        "Mixing_Duration": recipe.mixing_duration,
        "Mixer_Opening_Duration": recipe.mixer_opening_duration,
        "Mixer_SemiOpening_Duration": recipe.mixer_semi_opening_duration,
        "Mixer_SemiOpening2_Duration": recipe.mixer_semi_opening2_duration,
        "Lift_SemiPour_Duration": recipe.lift_semi_pour_duration,
        "Lift_Pour_Duration": recipe.lift_pour_duration,
        "Materials": materials,
    }
    atxcomm.recipe_to_ini_f(recipe_to_file, ord_fn)

    return {
        "message": f"{{Order}} {recipe.name} {sanitized_volume} m3 {{sent_to_production}}.",  # TODO REF: this does not belong to backend!
        "delivery_id": delivery.id,
    }


def _order_from_communication_file(fn):
    """ Returns order instance corresponding to communication file <fn>, or None if error occurs. """
    try:
        order_id = atxcomm.order_from_ini_f(fn).get("ID")
    except Exception:  # bad style, but comm module can afaik throw any exception, so catch it here
        logging.warning(f"Recieved update request, but file seems broken or noexistent: {fn}")
        return

    try:
        return model.Order.get_by_id(order_id)
    except DoesNotExist:
        logging.warning(f"Recieved update request for nonexisting order number {order_id}, file {fn}")


@model.db.atomic()
def update_order_status(fn):
    """Processes input file <fn> and updates corresponding order's status according to rules described in code"""
    order = _order_from_communication_file(fn)
    if not order:
        logging.info(f"no matching order for {fn} found, ignoring")
        return None
    if fn.endswith("std"):
        order.change_status(model.Order.STATUS_PRODUCTION)
    elif fn.endswith("ddm"):
        order.change_status(model.Order.STATUS_ABORTED_BEFORE_PRODUCTION)
    elif fn.endswith("int"):
        order.change_status(model.Order.STATUS_ABORTED_IN_PRODUCTION)


@model.db.atomic()
def update_material_consumption(fn):
    """Processes be2 input file <fn> and updates material consumption according to it's content.
    Also changes Order status when production finished - not superclean, though, but reality is not clean anyway
    Due to specification, all this is done when mixing is complete (e.g. we are only interested in .be2 files, not .be1)
    """
    if not fn.endswith("be2"):
        return None
    order = _order_from_communication_file(fn)
    if not order:
        logging.info(f"no matching order for {fn} found, ignoring")
        return None

    section_recipe = atxcomm.recipe_from_ini_f(fn)
    section_request = atxcomm.batch_request_from_ini_f(fn)
    section_evidence1 = atxcomm.batch_evidence1_from_ini_f(fn)
    section_evidence2 = atxcomm.batch_evidence2_from_ini_f(fn)

    # Every .be2 file means that one batch was produced.
    # Save everything to Batch model.
    # Dates in .be2 file are in local timezone (+1 hour for Prague)
    def datetime_to_t(date_str, time_str):
        return arrow.get(date_str + " " + time_str, "DD.MM.YYYY H:mm:ss", tzinfo=settings.TIMEZONE).timestamp()

    batch = model.Batch.create(
        order=order,
        filename=fn,
        additional_water=section_evidence2.get("Water_AdditionalKg"),
        consistency=section_evidence2.get("Consistency"),
        mixing_duration=section_evidence2.get("Mixing_Duration"),
        volume=section_request.get("Volume"),
        batch_number=section_request.get("Sequence"),
        batch_count=section_request.get("Total"),
        production_start_t=datetime_to_t(section_request.get("Date"), section_request.get("Time")),
        production_end_t=datetime_to_t(section_evidence2.get("Date"), section_evidence2.get("Time")),
        water_correction_e1=section_evidence1.get("Water_Correction"),
        water_correction_rq=section_request.get("Water_Correction"),
        water_temperature_calculated=section_request.get("Water_Temperature_Calculated"),
        continuous_mode=section_request.get("ContinuousMode"),
        moisture_rq=section_request.get("Batch_Moisture"),
        moisture_e2=section_evidence2.get("Moisture"),
        water_temperature=section_request.get("Water_Temperature"),
        production_mode_e1=section_evidence1.get("ProductionMode"),
        production_mode_e2=section_evidence2.get("ProductionMode"),
        cement_temperature=section_evidence2.get("Cement_Temperature"),
    )

    def find_material(mid, section):
        """ Returns material from <section>, which has corresponding <mid> (material ID from dispatch DB)
            Because of materials in production sections ([Batch_Request], [Batch_Evidence1] and [Batch_Evidence2])
            sometimes do not contain ID, they must be paired (via _k_orig part) to appropriate material in [Recipe] section, where ID is present.
            FIXME Can be refactored to atxpylib function find_by, but it is undocummented and I do not know how it is meant
        """
        for m in section["materials"]:
            try:
                recipe_material = [x for x in section_recipe["materials"] if x["_k_orig"] == m["_k_orig"]][0]
            except IndexError:
                # There is material in production section, that is not in Recipe.
                # This should be common case and we can safely ignore it. TODO QUE Review this assumption
                continue

            # This line SHOULD crash with KeyError, when there is material without ID in recipe_section (thus not existing in our DB):
            # It can indicate integrity problem (someone deleted material from our DB) or it indicates
            # that someone (propably manager) modified [Recipe] section, which is not permitted
            if recipe_material["ID"] == mid:
                return m

        # There is no material with such ID. It means that manager sent us .be2 file without that material
        # in one of production sections. This is propably not an error, maybe manager just does not used it
        # for some reason - so we just log this situation and continue TODO QUE: review this assumptions
        logging.warning(f"Can't find material {mid} in {fn}")

    # material consumptions: create BatchMaterial model AND new StockMovement
    for material in section_recipe["materials"]:
        material_id = material["ID"]
        material_rq = find_material(material_id, section_request)
        material_ev1 = find_material(material_id, section_evidence1)

        if material_rq and material_ev1:
            amount_consumed = material_ev1.get("Weight")
            ordermaterial = model.OrderMaterial.get_by_id(material_id)
            model.BatchMaterial.create(
                batch=batch,
                material=ordermaterial,
                amount_recipe=material["Weight"],
                amount_rq=material_rq.get("Weight"),
                amount_e1=amount_consumed,
                silo_major_rq=material_rq.get("Silo_Major"),
                silo_minor_rq=material_rq.get("Silo_Minor"),
                humidity_rq=material_rq.get("Humidity"),
                internal_humidity_rq=material_rq.get("Internal_Humidity"),
                density_rq=material_rq.get("Density"),
                temperature_rq=material_rq.get("Temperature"),
                bin_rq=material_rq.get("Bin"),
                delay_rq=material_rq.get("Delay"),
                silo_major_e1=material_ev1.get("Silo_Major"),
                silo_minor_e1=material_ev1.get("Silo_Minor"),
                humidity_e1=material_ev1.get("Humidity"),
            )
            model.StockMovement.create(
                material=ordermaterial.material,
                amount=-float(amount_consumed),
                comment=f"Used to produce order {order.id}, batch {batch.id}"
            )

    # be2 file with sequence == total (in [Batch_Request] section)
    # means that entire production has ended (all batches are produced). Other be2 files are ignored
    if section_request.get("Sequence") == section_request.get("Total"):
        order.change_status(model.Order.STATUS_FINISHED)


def save_materials_to_ini(materials, allowed_types, fn):
    logging.debug("will save %s materials to %s" % (len(materials), fn))

    cnt = {}
    to_save = {}
    for m in materials:
        m_type = m.type
        assert m_type in allowed_types, (m.name, m_type)
        cnt[m_type] = (cnt_ := cnt.get(m_type, 0)) + 1
        to_save[f"{m_type}{cnt_}"] = m.as_ini_section()
    if not to_save:
        logging.debug("no materials to save? bailing out")
        return

    # TODO REF: we have a wrapper for this (in atxpylib?) - find it and use it
    ini = AtxConfigParser()
    for k, v in to_save.items():
        atxcomm.generic_to_ini(v, ini, k)
    with open(f"{fn}_", "w", encoding="cp1250") as f:
        ini.write(f)
    os.replace(f"{fn}_", fn)


def quit_callback():
    logging.info("quit file callback")
    global _run
    _run = 0


def confirm(message):
    return input(f"WARNING: {message}. Proceed (yes/no)?") == "yes"


def process_input_folder(input_path, to_kdx_path):
    """Process all files in input communication folder: update database according to them
    and move everything to subfolder archive"""

    for ffn in func.list_of_files(input_path):
        logging.debug(f"found file {ffn}")
        if func.is_fn_temporary(ffn):
            logging.debug(f"skipping {ffn} - assuming it is temporary")
            continue
        try:
            update_order_status(ffn)
            update_material_consumption(ffn)
            if to_kdx_path:
                bn = os.path.basename(ffn)
                ffn2 = f"{to_kdx_path}/{bn}"
                logging.debug(f"copying {ffn} to {ffn2}")
                shutil.copy(ffn, ffn2)
            func.archive_input_file(ffn)
        except FileNotFoundError:
            logging.warning(f"file {ffn} disappeared!?!")


def manage_users():
    """Part of user interface: simple interactive user management.
    Can add user and list users.

    Security info:
    Management is protected with "master" password, which (it's hash) is hardcoded into the program.
    Safe for required safety standard (cracking needs source code AND brute force cracking SHA-256 hash),
    but master password is not simply changeable. It should be unified to password management practises of Asterix.
    """

    if model.User.hash(input("Enter master password:")) != settings.MASTER_PASSWORD_HASH:
        return 1

    def print_users():
        os.system("clear")
        print("Existing users:\n")
        print("  ID Username         Can edit users?")
        for user in model.User.select():
            print(f"{user.id:4} {user.username:15} {user.can_edit_users:2}")
        print(80 * "-")

    while True:
        print_users()
        print("Choices:")
        print("\t[Enter] to quit")
        print("\t<user_id> to toggle 'can edit users' value")
        print("\t<new_username> to add user")
        print()

        choice = input("Enter your choice:")
        if not choice:
            break

        try:
            user = model.User.get_by_id(int(choice))
        except ValueError:
            user = None
        except DoesNotExist:
            continue

        if user:
            user.can_edit_users = not user.can_edit_users
            user.save()
        else:
            username = choice
            password = input("New user password:")
            if username and password:
                model.User.create(username=username, password_hash_sha256=model.User.hash(password))
                print(f"User {username} created")


def _rename_after_import(path):
    path_new = path.removesuffix("/") + settings.IMPORTED_SUFFIX
    logging.info(f"Renaming historical data folder from {path} to {path_new}")
    os.replace(path, path_new)


# TODO REF: cut-n-pasted from pycontrol - unite!
def _get_mtime(fn):
    try:
        return os.stat(fn).st_mtime
    except:
        return None


def main():
    args = docopt.docopt(__doc__, version=__version__)

    os.makedirs(os.path.dirname(settings.LOG_FILE), exist_ok=True)
    atxutils.logging_setup("DEBUG", settings.LOG_FILE)

    logging.info("*" * 40)
    logging.info("starting dispatch v%s" % __version__)
    logging.debug("sqlite3 version: %s" % sqlite3.sqlite_version)

    cfg = {
        "input_path": args["--input-path"] or settings.INPUT_PATH,
        "output_path": args["--output-path"] or settings.OUTPUT_PATH,
        "material_ini_fn": args["--material-ini"] or settings.MATERIAL_INI_FILE,
    }

    if not os.path.exists(cfg["input_path"]):
        raise EnvironmentError(f"input_path folder {cfg['input_path']} not found")
    if not os.path.exists(cfg["output_path"]):
        raise EnvironmentError(f"output_path folder {cfg['output_path']} not found")

    from_kdx_path = args["--from-kdx"]
    to_kdx_path = args["--to-kdx"]
    if (from_kdx_path and not to_kdx_path) \
    or (not from_kdx_path and to_kdx_path):
        raise AssertionError("either none or both from and to paths have to be specified")
    if from_kdx_path and not os.path.exists(from_kdx_path):
        raise EnvironmentError(f"from_kdx_path {from_kdx_path} does not exist")
    if to_kdx_path and not os.path.exists(to_kdx_path):
        raise EnvironmentError(f"to_kdx_path {to_kdx_path} does not exist")
    kdx_material_ini_fn = args["--kdx-material-ini"]

    database_fn = model.db_file(args["--db"])
    model.mount_and_migrate_db(database_fn)

    if args["--clear"]:
        if confirm("This will irreversibly clear entire database"):
            logging.info("clearing database")
            model_utils.clear_db()
        return 0

    if args["--populate"]:
        model_utils.populate_db()
        logging.warning("Database was populated with TEST data")
        return 0

    if args["--bigdata"]:
        model_utils.bigdata(int(args["--bigdata"]))
        logging.warning(f"Database was populated with {args['--bigdata']} records")
        return 0

    if args["--integrity-check"]:
        logging.info("Integrity check started")
        errors = 0
        for table in model.TABLES:
            if not table.integrity_check():
                errors += 1
        logging.info(f"Integrity check ended, found problems in {errors} table(s)")
        return 1 if errors else 0

    if args["--users"]:
        return manage_users()

    atxd300_path = args["--import-atxd300-path"]
    if atxd300_path:
        assert os.path.isdir(atxd300_path)
    elif args["--import-atxd300"]:
        atxd300_path = atxutils.try_dir(["/asterix/atxd300/data"])
        assert atxd300_path
    if atxd300_path:
        ret = importer.import_atxd300_data(atxd300_path)
        _rename_after_import(atxd300_path)
        return ret

    minidisp_path = args["--import-minidisp-path"]
    if minidisp_path:
        assert os.path.isdir(minidisp_path)
    elif args["--import-minidisp"]:
        minidisp_path = atxutils.try_dir(["/atx300/minidisp/data/cs", "/atx300/minidisp/data/sk"])
        assert minidisp_path
    if minidisp_path:
        ret = importer.import_minidisp_data(minidisp_path)
        _rename_after_import(minidisp_path)
        return ret

    captions_json_fn = args["--captions-json"]
    if not captions_json_fn:
        logging.warning("captions.json path not specified, trying autodetection")
        captions_json_fn = atxutils.try_file(["./captions.json"])
    if captions_json_fn:
        logging.info("using captions.json in %s" % captions_json_fn)
    else:
        logging.warning("no captions.json file!")
    cfg["captions_fn"] = captions_json_fn  # TODO: why?
    captions_fn = cfg.get("captions_fn", "")

    glo.captions = load_captions(captions_fn)  # TODO REF: not very nice
    glo.setup = load_setup(settings.CONFIG_FILE)  # TODO REF: not very nice
    glo.cfg = cfg  # TODO REF: not very nice

    logging.debug("setup: %s" % glo.setup)
    logging.debug("cfg: %s" % cfg)

    if not args["--no-web"]:
        port = settings.SERVER_PORT
        thr_web = threading.Thread(target=web.start, args=(port,), daemon=True)
        thr_web.start()
    else:
        thr_web = None

    quit_fn = "quit"
    qf = QuitFile(quit_fn)
    if qf.check_and_delete():
        logging.info("stale quit file found, removed")
    qf.start_checking(quit_callback)

    kdx_material_ini_mod_t = None  # TODO REF: define this elsewhere
    kdx_failed_fns = []  # TODO REF: define this elsewhere

    global _run
    while _run:
        process_input_folder(cfg.get("input_path"), to_kdx_path)

        if kdx_material_ini_fn:
            x = _get_mtime(kdx_material_ini_fn)
            if x is not None and x != kdx_material_ini_mod_t:
                bridges.kdx_material_ini(kdx_material_ini_fn)
                kdx_material_ini_mod_t = x
                glo.export_material_ini = 1

        if glo.export_material_ini:
            glo.export_material_ini = 0
            save_materials_to_ini(model.Material.select(), model.Material.ALLOWED_TYPES, cfg["material_ini_fn"])

        if from_kdx_path:
            # Bridge mode for kdx
            # Note: exceptions in (pretty complex) bridge code are not caught, philosophy is: let program crash
            kdx_failed_fns = bridges.kdx(from_kdx_path, cfg.get("output_path"), kdx_failed_fns)

        # TODO: don't just guard time.sleep for KeyboardInterrupt, it can come at any time
        try:
            time.sleep(settings.SLEEP_INTERVAL)
        except KeyboardInterrupt:
            break

    logging.debug("after loop")

    # Backup database on exit
    timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    backup_fn = func.asterixed_path(settings.DB_BACKUP_PATH, f"{timestamp}.sqlite3")
    os.makedirs(settings.DB_BACKUP_PATH, exist_ok=True)
    shutil.copy(database_fn, backup_fn)
    logging.info(f"Database backed up to {backup_fn}")

    if thr_web:
        web.stop()
        # TODO REF NTH QUE shouldn't we join the thread?
    return 0


if __name__ == "__main__":
    sys.exit(main())
